#include <stdio.h>
#include <libf/sl/xstdint.h>


/*

= Deflate

	Lz77 & Huffman:

	length: Match data length.
	distance: Forward offset equal the matching data.
	extra Bits: More compact encoding of 'length' and 'distance' data.

== Length:

@
	|Code|Extra bits|Length
	|257 |0         |3
	|258 |0         |4
	|259 |0         |5
	|260 |0         |6
	|261 |0         |7
	|262 |0         |8
	|263 |0         |9
	|264 |0         |10
	|265 |1         |11-12
	|266 |1         |13-14
	|267 |1         |15-16
	|268 |1         |17-18
	|269 |2         |19-22
	|270 |2         |23-26
	|271 |2         |27-30
	|272 |2         |31-34
	|273 |3         |35-42
	|274 |3         |43-50
	|275 |3         |51-58
	|276 |3         |59-66
	|277 |4         |67-82
	|278 |4         |83-98
	|279 |4         |99-114
	|280 |4         |115-130
	|281 |5         |131-162
	|282 |5         |163-194
	|283 |5         |195-226
	|284 |5         |227-257
	|285 |0         |258

== Distance

@
	|Code|Extra bits|Distance
	|0   |0         |1
	|1   |0         |2
	|2   |0         |3
	|3   |0         |4
	|4   |1         |5-6
	|5   |1         |7-8
	|6   |2         |9-12
	|7   |2         |13-16
	|8   |3         |17-24
	|9   |3         |25-32
	|10  |4         |33-48
	|11  |4         |49-64
	|12  |5         |65-96
	|13  |5         |97-128
	|14  |6         |129-192
	|15  |6         |193-256
	|16  |7         |257-384
	|17  |7         |385-512
	|18  |8         |513-768
	|19  |8         |769-1024
	|20  |9         |1025-1536
	|21  |9         |1537-2048
	|22  |10        |2049-3072
	|23  |10        |3073-4096
	|24  |11        |4097-6144
	|25  |11        |6145-8192
	|26  |12        |8193-12288
	|27  |12        |12289-16384
	|28  |13        |16385-24576
	|29  |13        |24577-32768

== Fixd Huffman Code (Literal & Length)

	Length-Distance to Symbol:

	'Codes' is generated by gen_codes().

@
	|Value   |Bits|Codes
	|0-143   |8   |00110000-10111111
	|144-255 |9   |110010000-111111111
	|256-279 |7   |0000000-0010111
	|280-287 |8   |11000000-11000111

== Dynamic Huffman Code

	16
	17
	18
	0
	8
	7,9,6,10,5,11,4,12,3,13,2,14,1,15

*/

struct deflate_ct_data {
	union {
		uint16 freq; /* character freq */
		uint16 code; /* huffman code */
	} fc;
	union {
		uint16 dad; /* huffman parent node */
		uint16 len; /* code length */
	} dl;
};

struct deflate_tree_desc {
	struct deflate_ct_data *dynamic_tree;
	struct deflate_ct_data *static_tree;
	uint16 *extra_bits;
	uint16 extra_base;
	uint16 elems;
	uint16 max_length;
	uint16 max_code;
};

struct deflate_tree_ctx {
	uint32 heap_max;
};

struct deflate_lz77_ctx {
	uint8 buf[1 << 15]; /* literal */
	uint8 buf_flag[1 << 12]; /* distance flag */
	uint16 buf_dis[1 << 15]; /* distance */
	uint32 len; /* buffer length */
};

struct deflate_ctx {
	uint16 lenbase[29];
	uint16 lencode[256];
	uint16 disbase[30];
	uint16 discode[512];
	struct deflate_ct_data lentree[288];
	uint16 bitlen_count[16];
	struct deflate_ct_data distree[30];
};

static int extra_lbits[29] = {
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 2, 2, 2, 2,
	3, 3, 3, 3, 4, 4, 4, 4,
	5, 5, 5, 5, 0
	};

static int extra_dbits[30] = {
	 0,  0,  0,  0,  1,  1,
	 2,  2,  3,  3,  4,  4,
	 5,  5,  6,  6,  7,  7,
	 8,  8,  9,  9, 10, 10,
	11, 11, 12, 12, 13, 13
	};

static uint16 _bit_reverse(uint16 c, uint16 len) {
	uint16 r = 0;
	while (len--) {
		r |= c & 1;
		r <<= 1;
		c >>= 1;
	}

	return r >> 1;
}

static void _gen_codes(struct deflate_ct_data *tree, const uint16 *bitlen_count,
		uint32 n) {
	uint16 next_code[16];
	uint16 code = 0;

	for (int32 i = 1; i < 16; i++) {
		code = (code + bitlen_count[i - 1]) << 1;
		next_code[i] = code;
	}

	for (uint32 i = 0; i < n; i++) {
		uint32 len = tree[i].dl.len;
		if (!len) {
			tree[i].fc.code = (uint16)-1;
			continue;
		}
		tree[i].fc.code = _bit_reverse(next_code[len]++, len);
	}
}
#if 0
static void _pqdownheap(struct ct_data *tree, uint32 k) {
	int v = heap[k];
	int j = k << 1;
	while (j <= heap_len) {
		if (j < heap_len
				&& (tree[heap[j+1]].fc.freq < tree[heap[j]].fc.freq
				|| (tree[heap[j+1]].fc.freq == tree[heap[j]].fc.freq
				&& depth[heap[j+1]] <= depth[heap[j]])))
			j++;
		if ((tree[v].fc.freq < tree[heap[j]].fc.freq
				|| (tree[v].fc.freq == tree[heap[j]].fc.freq
				&& depth[v] <= depth[heap[j]])))
			break;
		heap[k] = heap[j];
		k = j;
		j <<= 1;
	}
	heap[k] = v;
}

static void _build_tree(, struct tree_desc *desc) {
	ct_data *tree = desc->dyn_tree;
	ct_data *stree = desc->static_tree;
	int elems = desc->elems;
	int n, m;
	int max_code = -1;
	int node = elems;
	heap_len = 0;
	heap_max = (2*(256 +1+29)+1);

	for (int32 i = 0; i < ctx->elems; i++) {
		if (tree[i].fc.freq) {
			heap[++heap_len] = max_code = i;
			depth[i] = 0;
		} else {
			tree[i].dl.len = 0;
		}
	}

	while (heap_len < 2) {
		int new = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
		tree[new].fc.freq = 1;
		depth[new] = 0;
		opt_len--;
		if (stree)
			static_len -= stree[new].dl.len;
	}

	desc->max_code = max_code;
	for (n = heap_len/2; n >= 1; n--)
		pqdownheap(tree, n);
	do {
		n = heap[1];
		heap[1] = heap[heap_len--];
		pqdownheap(tree, 1);
		m = heap[1];
		heap[--heap_max] = n;
		heap[--heap_max] = m;
		tree[node].fc.freq = tree[n].fc.freq + tree[m].fc.freq;
		depth[node] = (uch)((depth[n] >= depth[m] ? depth[n] : depth[m]) + 1);
		tree[n].dl.dad = tree[m].dl.dad = (ush)node;
		heap[1] = node++;
		pqdownheap(tree, 1);
	} while (heap_len >= 2);
	heap[--heap_max] = heap[1];

	gen_bitlen((tree_desc *)desc);
	gen_codes ((ct_data *)tree, max_code);
}
#endif

void deflate_init(struct deflate_ctx *ctx) {
	uint32 code = 0;
	uint32 len = 0;
	uint32 dis = 0;

	/* length code */
	for (; code < 28; code++) {
		ctx->lenbase[code] = len;
		for (int32 i = 0; i < (1 << extra_lbits[code]); i++)
			ctx->lencode[len++] = code;
	}
	ctx->lencode[len - 1] = code;
	printf("%d\n", len);

	/* distance code */
	code = 0;
	for (; code < 16; code++) {
		ctx->disbase[code] = dis;
		for (int32 i = 0; i < (1 << extra_dbits[code]); i++)
			ctx->discode[dis++] = code;
	}

	dis >>= 7;
	for (; code < 30; code++) {
		ctx->disbase[code] = dis << 7;
		for (int32 i = 0; i < (1 << (extra_dbits[code] - 7)); i++)
			ctx->discode[256 + dis++] = code;
	}

	/* length tree */
	for (int32 i = 0; i < 16; i++)
		ctx->bitlen_count[i] = 0;

	int32 n = 0;
	for (; n < 144; n++) { /* 0~143: 8-bit length */
		ctx->lentree[n].dl.len = 8;
		ctx->bitlen_count[8]++;
	}
	for (; n < 256; n++) { /* 144~255: 9-bit length */
		ctx->lentree[n].dl.len = 9;
		ctx->bitlen_count[9]++;
	}
	for (; n < 280; n++) { /* 256~279: 7-bit length */
		ctx->lentree[n].dl.len = 7;
		ctx->bitlen_count[7]++;
	}
	for (; n < 288; n++) { /* 280~287: 8-bit length */
		ctx->lentree[n].dl.len = 8;
		ctx->bitlen_count[8]++;
	}
	_gen_codes(ctx->lentree, ctx->bitlen_count, 288);

	/* distance tree */
	for (int32 i = 0; i < 30; i++) {
		ctx->distree[i].dl.len = 5;
		ctx->distree[i].fc.code = _bit_reverse(i, 5);
	}
}

int main(int argc, char *argv[]) {
	struct deflate_ctx ctx;
	deflate_init(&ctx);

	printf("{\n");
	for (int32 i = 0; i < 29; ) {
		printf(" %3d\n",
			ctx.lenbase[i]);
		if (!(++i % 8))
			printf("\n");
	}
	printf("}\n\n");

	printf("{\n");
	for (int32 i = 0; i < 30; ) {
		printf(" %3d,",
			ctx.disbase[i]);
		if (!(++i % 8))
			printf("\n");
	}
	printf("}\n\n");

	printf("{\n");
	for (int32 i = 0; i < 256; ) {
		printf("%3d,",
			ctx.lencode[i]);
		if (!(++i % 12))
			printf("\n");
	}
	printf("}\n\n");

	printf("{\n");
	for (int32 i = 0; i < 512; ) {
		printf("%3d,",
			ctx.discode[i]);
		if (!(++i % 12))
			printf("\n");
	}
	printf("}\n\n");

	printf("{\n");
	for (int32 i = 0; i < 288; ) {
		printf(" { { %3d }, { %d } },",
			ctx.lentree[i].fc.code, ctx.lentree[i].dl.len);
		if (!(++i % 2))
			printf("\n");
	}
	printf("}\n\n");

	printf("{\n");
	for (int32 i = 0; i < 30; ) {
		printf(" { { %3d }, { %d } },",
			ctx.distree[i].fc.code, ctx.distree[i].dl.len);
		if (!(++i % 2))
			printf("\n");
	}
	printf("}\n\n");

	return 0;
}
